日志模块为系统提供了故障恢复的功能，该系统目前采用undo/redo日志，恢复策略简单说就是重做已提交事务，回滚未提交事务。日志系统采用独立的缓冲区，用来构建主存和日志文件的映射。

对于undo/redo日志，日志和数据修改的落盘顺序应该遵循如下规则：
- 数据修改的日志要先于脏数据落盘
- commit日志一旦出现就必须立刻落盘
- abort日志必须在该事务完全回滚并且数据落盘之后才能落盘

# LogType
Log目前有6种操作，分别是insert, delete, update, begin, commit和abort。后三种为事务控制操作，前三种为数据编辑操作。

# LogRecord
LogRecord是日志记录的基类，它包含了日志操作的类型、日志序列号lsn、整个日志记录的长度、关联事务的id，以及该事务上一条日志的lsn。

lsn是对日志的唯一标识符。当前代码并未给出lsn的生成算法。如果仅仅用来标识日志产生的时间，则lsn可以采用步长为1的递增策略产生，但是这样做对于定位日志没有提供帮助。比如说日志项在文件中可能是分散存在的，相同事务的日志项之间可能夹杂着其他事务的日志，如果要进行undo/redo的话，则需要逆向/正向遍历文件，这无疑是低效的。因此可以考虑将lsn定义为文件中的字节偏移量，既能保证唯一性，又可以快速定位日志。这样通过prev_lsn就可以快速地找到同一事务的逆序的日志序列，进行undo操作。只要合理地设置检查点，并覆盖写入检查点之前的日志内容，便可以保证lsn不会溢出。

# LogBuffer
LogBuffer是日志缓冲区，当前系统只有一个buffer。该buffer是以字节为单位的，没有页的结构。由于是唯一的，因此需要阻塞写入，可以考虑双缓冲。

LogBuffer目前被LogManager和recoveryManager以值类型的形式持有，并不理解为什么要这么做，要将LogBuffer分成两个对象分别管理。

# LogManager
LogManager是日志管理结构，用于将日志写入buffer，并将buffer刷入磁盘。其内部保存着全局lsn，用来给每一条日志记录分配lsn，还保存着已经持久化到磁盘的最后一个lsn，方便进行定位。

# RecoveryManager
RecoveryManager用来进行恢复处理，它提供了analyze, undo, redo三个方法，分别用来收集要恢复的内容，撤销修改和重做修改。analyze需要从日志文件中的最后一个checkpoint开始，查找已提交和未提交的事务。未提交的事务组织成一个表(ATT)，用来回滚。已提交的事务构建一个脏页表(DPT)，用来重做。

这里有一个细节需要注意：为什么undo需要用未提交事务的表ATT，而已提交事务需要用脏页表DPT，而不是已提交事务的表？因为redo需要严格按照发生的时间顺序重做，它并不是以事务为中心的。先开始的事务在串行化之后并不一定先发生，如果按照开始的时间顺序安排重做，可能会发生针对同一个元素重做的顺序与实际修改的顺序不同的情况，因此需要以页为中心，在页内按照lsn正向排列进行修改。而undo的事务都是未提交的，在其他事务看来它们从未发生，否则就会出现“读未提交”的情况，因此只需要按照事务内部逆序回滚即可，也就是以事务为中心回滚。