# Optimize模块

optimizer负责进行查询优化并生成查询执行计划。负责用语法分析模块的`Query`生成一个个的具体执行计划`Plan`

## Optimizer类

持有一个`Planner`对象和`SmManager`对象。负责接受`analyse`阶段传入的`Query`

核心函数`plan_query`调用do_planner，事务语句和其他特殊描述语句走别的逻辑。

## Planner类

Planner 类是一个查询优化器
- 负责选择合适的连接策略。
- 进行逻辑和物理优化
- 根据查询生成不同类型的执行计划（排序、连接等）
- 核心函数`do_planner`对Query的种类做判断，生成DDL语句和DML语句的查询执行计划，输出`Plan`对象。可能会在如select语句这样递归调用来生成子算子。

`make_one_rel` 方法用于为**单个查询**生成执行计划。先生成表扫描执行计划：遍历查询中的所有表。对每个表，获取与该表相关的查询条件，并判断该表是否有索引。如果有索引，则使用索引扫描。将生成的扫描计划存储在 `table_scan_executors` 中。
如果查询中存在连接条件，先处理第一层连接条件，并生成连接计划。根据连接条件生成后续的连接（每次生成一个新的 JoinPlan，并将其与现有的 JoinPlan 连接）。使用嵌套循环连接或排序合并连接作为连接策略(**什么是连接策略?**)。 如果没有连接条件，且查询只涉及一个表，则直接返回对应的表扫描计划。如果有多个表，且还没有为某些表生成连接计划，则需要为这些表生成连接操作。
最后返回生成的连接计划或表扫描计划

`generate_select_plan`方法从查询中的表获取所有列的信息。查找与排序条件匹配的列，生成一个 TabCol 对象，用于表示排序的列。生成并返回一个 `SortPlan`(存在planroot里面)

`generate_select_plan`方法里面两个优化函数**没实现**，估计是select语句算子的层层拆分？

## Plan类

Plan类顶层有DMLPlan、DDLPlan、OtherPlan子类。顶层Plan其下是各个算子的**逻辑子计划**。